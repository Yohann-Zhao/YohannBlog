<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Callsign Practice | Aviation English | Yohann's Aviation Notes</title>
    <link rel="stylesheet" href="styles.css">

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-G3TQJTQ67B"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-G3TQJTQ67B');
    </script>


    <link rel="icon" type="image/x-icon" href="yohann_favicon.ico">
</head>

<style>
    /* 新增样式：导航路径样式 */
    .breadcrumb {
        padding: 1rem;
        padding-left: 10%;
        background: var(--background-color);
        box-shadow: var(--shadow-sm);
    }

    .breadcrumb a {
        text-decoration: none;
        color: var(--text-color);
        font-size: 1rem;
        transition: var(--transition);
    }

        .breadcrumb a:hover {
            color: var(--primary-color);
        }

    .breadcrumb span {
        color: var(--text-color);
        font-size: 0.9rem;
        margin: 0 0.5rem;
    }
</style>

<style>
.nav-breadcrumb-container {
    position: -webkit-sticky; /* Safari */
    position: sticky;
    top: 0;
    background-color:; /* 可选：设置背景颜色 */
    z-index: 1000; /* 确保它在其他内容之上 */
}

</style>
<body>

    <header>
        <div class="language-switcher">
            <a href="callsign_practice.html">中文</a> | <a href="callsign_practice_en.html">English</a>
        </div>
        <div class="header-content">
            <h1>Callsign Practice</h1>
        </div>
    </header>

    <div class="nav-breadcrumb-container">
        <nav>
            <ul>
                <li><a href="index_en.html">Home</a></li>
                <li><a href="theory_en.html">Theory Exams</a></li>
                <li><a href="flight-training_en.html">Flight Training</a></li>
                <li><a href="aviation-english_en.html"  class="active">Aviation English</a></li>
                <li><a href="about_en.html">About Me</a></li>
            </ul>
        </nav>

        <!-- 导航路径 -->
        <div class="breadcrumb">
            <a href="aviation-english_en.html">All Topics</a>
            <span>></span>
            <a id="subject-name">Radio Call</a>
        </div>
        
    </div>

    <main class="container">
        <section id="radio call into" class="text-section">
            <h2>Basic Call Sign Pronunciation</h2>
            <p>Call signs are identifiers for aircraft, consisting of letters and numbers.</p>
            <h3>Pronunciation Rules</h3>
                <li>Letters: A (Alpha), B (Bravo), C (Charlie), D (Delta), E (Echo), F (Foxtrot), G (Golf), H (Hotel), I (India), J (Juliet), K (Kilo), L (Lima), M (Mike), N (November), O (Oscar), P (Papa), Q (Quebec), R (Romeo), S (Sierra), T (Tango), U (Uniform), V (Victor), W (Whiskey), X (X-ray), Y (Yankee), Z (Zulu)</li>
                <li>Numbers: 3 (Tree), 9 (Niner); numbers in call signs are grouped in pairs</li>
            <h3>Pronunciation Examples</h3>
                <li>AI9: "Alpha India Niner", 8470: "Eighty Four Seventy", 172D: "One Seventy Two Delta"</li>

                <style>
                    .section {
                        padding: 3em;
                    }
                    
                    .section h2 {
                        font-size: 1.8em;
                        margin-bottom: 0.5em;
                        border-bottom: 2.5px solid var(--primary-color);
                        padding-bottom: 0.2em;
                    }
                    
                    .section h3 {
                        font-size: 1.4em;
                        margin-top: 1em;
                        margin-bottom: 0.5em;
                        color: #333;
                    }
                    
                    .section h4 {
                        font-size: 1.1em;
                        margin-top: 0.8em;
                        margin-bottom: 0.4em;
                        color: var(--primary-color);
                    }
                    
                    .section ul {
                        list-style-type: disc;
                        margin-left: 1.5em;
                        margin-bottom: 1em;
                    }
                    
                    .section ul li {
                        margin-bottom: 0.5em;
                    }
                    
                    .section p {
                        margin-bottom: 1em;
                        line-height: 1.6;
                    }
                    </style>
        </section>

        <section id="Real_AU_callsign_reader" class="text-section">
            <h2>Call Sign Dictation Practice</h2>
            <details>
                <summary>Usage Instructions</summary>
                <div class="section">
                    <h4>General</h4>
                    <p>- General Aviation Callsigns: click the "General Aviation Callsigns" button to play simulated traffic (aircraft type + callsign). Practice identifying and transcribing only the callsign.</p>
                    <p>- 4-digit Number Practice: click the "4-digit Number Practice" button to play four-digit number groups for numeric reading practice.</p>
                    <p>- Letter Practice: click "English Letter Practice" to practice letter dictation; customize the letter set and length in "More Options".</p>
                    <h4>Tips</h4>
                    <ul>
                        <li>Use "More Options" to adjust speed, accent, counts per group, and custom letters.</li>
                        <li>Enabling "Simulate VHF/ATC Tone" will make playback sound closer to real VHF AM radio (may add short processing latency).</li>
                        <li>Controls: Enter=Check Answer, Space=Replay/Pause/Resume, R=Regenerate, H=Show/Hide Answer.</li>
                    </ul>
                </div>
            </details>
            <details>
                <summary>More Options</summary>
                <div class="control-group">
                    <div class="input-group">
                        <label>Number of Call Signs per Group:</label>
                        <input type="number" id="callsignCount" value="1" min="1" max="50">
                    </div>
                    <div class="input-group">
                        <label>Custom Letters:</label>
                        <input type="text" id="customLetters" maxlength="26" placeholder="Letter Practice: e.g., XYZR, default A-Z">
                    </div>
                    <div class="input-group">
                        <label>Number of Letters per Group:</label>
                        <input type="number" id="letterCount" value="9" min="1" max="50">
                    </div>
                </div>
                <div class="control-group">
                    <div id="speedControl">
                        <label>Speed Adjustment
                            <input type="range" id="speed" min="0.3" max="2" value="1.2" step="0.1" oninput="updateSpeed(this.value)">
                            <span id="speedValue">1.2</span>
                        </label>
                    </div>
                    <div class="input-group">
                        <label>Accent:</label>
                        <select id="accentSelect">
                            <option value="australian">🇦🇺 Australian English</option>
                            <option value="american">🇺🇸 American English</option>
                            <option value="british">🇬🇧 British English</option>
                            <option value="indian">🇮🇳 Indian English</option>
                            <option value="southeast_asia">🇵🇭 Southeast Asian English</option>
                            <option value="mixed" selected>🌍 Mixed Accents</option>
                        </select>
                    </div>
                    <div class="input-group">
                    <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
                        <input type="checkbox" id="atcToneCheckbox" checked> Simulate VHF/ATC Tone
                    </label>
                </div>
            </details>
            <style>
                /* 基础折叠面板样式 */
                details {
                    border: 1px solid #e0e0e0;
                    border-radius: 8px;
                    margin: 1rem 0;
                    transition: all 0.3s ease;
                }
                
                /* 鼠标悬停效果 */
                details:hover {
                    border-color: #3498db;
                    box-shadow: 0 2px 8px rgba(52, 152, 219, 0.1);
                }
                
                /* 标题样式 */
                details summary {
                    padding: 12px 16px;
                    background: #f8f9fa;
                    color: #2c3e50;
                    font-weight: 500;
                    cursor: pointer;
                    list-style: none; /* 隐藏默认箭头 */
                    border-radius: 8px 8px 0 0;
                    position: relative;
                    transition: background 0.2s ease;
                }
                
                /* 移除默认聚焦轮廓 */
                details summary:focus {
                    outline: none;
                }
                
                /* 自定义展开图标 */
                details summary::-webkit-details-marker {
                    display: none;
                }
                details summary::after {
                    content: "▶";
                    position: absolute;
                    right: 16px;
                    top: 50%;
                    transform: translateY(-50%);
                    font-size: 0.8em;
                    color: #7f8c8d;
                    transition: transform 0.2s ease;
                }
                details[open] summary::after {
                    transform: translateY(-50%) rotate(90deg);
                }
                
                /* 展开内容区域 */
                details .control-group {
                    padding: 16px;
                    background: white;
                    border-radius: 0 0 8px 8px;
                    display: grid;
                    gap: 1.2rem;
                }
                
                /* 响应式布局 */
                @media (min-width: 768px) {
                    details .control-group {
                        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                    }
                }
                
                /* 输入组样式 */
                .input-group {
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                }
                
                .input-group label {
                    font-size: 0.9em;
                    color: #34495e;
                    font-weight: 500;
                }
                
                .input-group input[type="number"],
                .input-group input[type="text"] {
                    padding: 8px 12px;
                    border: 1px solid #bdc3c7;
                    border-radius: 4px;
                    width: 100%;
                    max-width: 300px;
                    transition: border-color 0.2s ease;
                }
                
                .input-group input:focus,
                .input-group select:focus {
                    border-color: #3498db;
                    outline: none;
                    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.15);
                }
                
                .input-group select {
                    padding: 0.7rem;
                    border: 1px solid #bdc3c7;
                    border-radius: 4px;
                    width: 100%;
                    max-width: 300px;
                    font-size: 0.95rem;
                    background-color: white;
                    cursor: pointer;
                    transition: border-color 0.2s ease;
                }
                
                /* 滑动条特殊样式 */
                #speedControl {
                    padding: 8px 0;
                }
                
                #speedControl input[type="range"] {
                    width: 200px;
                    margin: 0 10px;
                    vertical-align: middle;
                }
                
                #speedValue {
                    display: inline-block;
                    min-width: 40px;
                    text-align: center;
                    font-weight: bold;
                    color: #3498db;
                }
                
                /* 复选框标签排版 */
                .input-group label[style*="cursor: pointer"] {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    user-select: none;
                }
                
                /* 展开动画 */
                details[open] summary {
                    background: #f1f8ff;
                    border-bottom: 1px solid #e0e0e0;
                }
                
                @keyframes slideDown {
                    from { opacity: 0; transform: translateY(-10px) }
                    to { opacity: 1; transform: translateY(0) }
                }
                
                details[open] .control-group {
                    animation: slideDown 0.3s ease-out;
                }
            </style>            

            <div class="button-group">
                <button onclick="playTransportAirline()">Transport Airline Callsigns</button>
                <button onclick="playSimulated()"> General Aviation Callsigns</button>
                <button onclick="playFormat1()">4-digit Number Practice</button>
                <button onclick="playLetters()">English Letter Practice</button>
            </div>
            <div class="button-group">
                <button onclick="toggleAnswer()">
                    <span id="toggleIcon">🔍</span> 
                    <span id="toggleText">Show Answer</span>
                </button>
                <button id="pauseResumeBtn" onclick="togglePauseResume()" disabled>⏸ Replay/Pause/Resume</button>
                <button id="stopBtn" onclick="stopPlayback()" disabled>⏹ Stop</button>
            </div>
            <div class="shortcut-hints-container">
                <div class="shortcut-hints">
                    <kbd>Enter</kbd>Check Answer | 
                    <kbd>Space</kbd>Replay/Pause/Resume | 
                    <kbd>R</kbd>Regenerate | 
                    <kbd>H</kbd>Hide Answer
                </div>
            </div>
            <div id="answer"></div>
        
            <div class="answer-input-group">
                <input type="text" id="userAnswer" placeholder="Enter your answer here, press Enter to check" 
                       onkeypress="if(event.key === 'Enter') checkAnswer()">
                <button onclick="checkAnswer()">✓ Check Answer</button>
            </div>
            <div id="answerFeedback" class="feedback"></div>
            

            <style>
                .shortcut-hints-container {
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    margin-top: 1rem;
                }

                .shortcut-hints {
                    font-size: 0.9rem;
                    color: var(--text-color);
                }
                
                .shortcut-hints kbd {
                    background: var(--secondary-color);
                    color: white;
                    padding: 0.2rem 0.5rem;
                    border-radius: 4px;
                    margin: 0 0.2rem;
                }
            </style>

            <style>
                :root {
                    --success-color: #27ae60;
                    --danger-color: #e74c3c;
                    --border-color: #bdc3c7;
                }
               
                .control-group {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
                    gap: 1.2rem;
                    background: var(--light-blue);
                    padding: 1.5rem;
                    border-radius: 12px;
                    margin-bottom: 2rem;
                    border: 1px solid #d4e3f0;
                }
            
                .input-group {
                    display: flex;
                    flex-direction: column;
                    gap: 0.4rem;
                }
            
                label {
                    font-weight: 600;
                    font-size: 0.9rem;
                    color: var(--primary-color);
                }
            
                input[type="text"],
                input[type="number"] {
                    padding: 0.7rem;
                    border: 2px solid var(--border-color);
                    border-radius: 6px;
                    font-size: 0.95rem;
                    transition: all 0.2s ease;
                }
            
                input[type="text"]:focus,
                input[type="number"]:focus {
                    border-color: var(--secondary-color);
                    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.15);
                    outline: none;
                }
            
                .button-group {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 0.8rem;
                    margin: 2rem 0;
                    justify-content: center;
                }
            
                button {
                    padding: 0.8rem 1.4rem;
                    border: none;
                    border-radius: 6px;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    display: inline-flex;
                    align-items: center;
                    gap: 0.6rem;
                    background: var(--secondary-color);
                    color: white;
                }
            
                button:hover {
                    background: var(--accent-color);
                }
            
                button:disabled {
                    opacity: 0.6;
                    cursor: not-allowed;
                    background: #95a5a6;
                }
            
                #stopBtn {
                    background: var(--danger-color);
                }
            
                button[onclick="toggleAnswer"] {
                    background: #7f8c8d;
                }
            
                #speedControl {
                    background: var(--light-blue);
                }
            
                input[type="range"] {
                    width: 200px;
                    height: 4px;
                    background: #dfe6e9;
                    border-radius: 2px;
                }
            
                input[type="range"]::-webkit-slider-thumb {
                    width: 16px;
                    height: 16px;
                    background: var(--secondary-color);
                }
            
                #answer {
                    display: none; /* 默认隐藏 */
                    background: var(--light-blue);
                    padding: 1.2rem;
                    border-radius: 8px;
                    font-family: 'Courier New', monospace;
                    font-size: 1.1rem;
                    border: 2px solid var(--secondary-color);
                    margin-top: 1.5rem;
                }
            
                .input-group label input[type="checkbox"] {
                    margin-right: 0.5rem;
                    accent-color: var(--secondary-color);
                }
            
                @media (max-width: 600px) {
                    body {
                        padding: 1rem;
                    }
                    
                    .button-group {
                        flex-direction: column;
                    }
                    
                    button {
                        justify-content: center;
                    }
                }
            </style>

                <!-- 新增答题区域样式 -->
            <style>
                .answer-input-group {
                    display: flex;
                    gap: 0.8rem;
                    margin: 1.5rem 0;
                }

                #userAnswer {
                    flex: 1;
                    padding: 0.8rem;
                    border: 2px solid var(--border-color);
                    border-radius: 6px;
                    font-size: 1rem;
                    transition: all 0.2s ease;
                }

                #userAnswer:focus {
                    border-color: var(--secondary-color);
                    outline: none;
                }

                .feedback {
                    padding: 1rem;
                    border-radius: 8px;
                    margin: 1rem 0;
                    font-weight: 600;
                    transition: all 0.3s ease;
                }

                .feedback.correct {
                    background: var(--success-color);
                    color: white;
                }

                .feedback.incorrect {
                    background: var(--danger-color);
                    color: white;
                }
            </style>
        
            <script>
                const GOOGLE_TTS_API_KEY = 'AIzaSyB8kUi4-oUJgYZQFidBvtGsjLrS1dxw1W4'; 
                
                // Different regional English accent voice library
                const ACCENT_VOICES = {
                    australian: [
                        'en-AU-Standard-A',
                        'en-AU-Standard-B',
                        'en-AU-Standard-C',
                        'en-AU-Standard-D'
                    ],
                    american: [
                        'en-US-Standard-A',
                        'en-US-Standard-B',
                        'en-US-Standard-C',
                        'en-US-Standard-D'
                    ],
                    british: [
                        'en-GB-Standard-A',
                        'en-GB-Standard-B',
                        'en-GB-Standard-C',
                        'en-GB-Standard-D'
                    ],
                    indian: [
                        'en-IN-Standard-A',
                        'en-IN-Standard-B',
                        'en-IN-Standard-C'
                    ],
                    southeast_asia: [
                        'en-SG-Standard-A'  // Singapore English
                    ],
                    mixed: [
                        'en-AU-Standard-A', 'en-AU-Standard-B',
                        'en-AU-Standard-C', 'en-AU-Standard-D',
                        'en-US-Standard-A', 'en-US-Standard-B',
                        'en-US-Standard-C', 'en-US-Standard-D',
                        'en-GB-Standard-A', 'en-GB-Standard-B',
                        'en-GB-Standard-C', 'en-GB-Standard-D',
                        'en-IN-Standard-A', 'en-IN-Standard-B', 'en-IN-Standard-C',
                        'en-SG-Standard-A'
                    ]
                };
        
                const aviationMap = {
                    'A': 'Alpha', 'B': 'Bravo', 'C': 'Charlie', 'D': 'Delta',
                    'E': 'Echo', 'F': 'Foxtrot', 'G': 'Golf', 'H': 'Hotel',
                    'I': 'India', 'J': 'Juliet', 'K': 'Kilo', 'L': 'Lima',
                    'M': 'Mike', 'N': 'November', 'O': 'Oscar', 'P': 'Papa',
                    'Q': 'Quebec', 'R': 'Romeo', 'S': 'Sierra', 'T': 'Tango',
                    'U': 'Uniform', 'V': 'Victor', 'W': 'Whiskey', 'X': 'Xray',
                    'Y': 'Yankee', 'Z': 'Zulu'
                };
        
                const aircraftTypes = [
                    "Cessna","Cessna Citation", "Brumby", "Sling", "Diamond", "Saab", 
                    "Beech King Air","Beech Baron", "Embraer", "Bombardier", "Piper", "Piper warrior", "Piper Chieftain","Beechcraft", "Eclipse", "Jabiru",
                    "Gulfstream", "Cirrus", "Mooney", "Robin", "Socata", "BRM Aero",
                    "Pilatus", "Tecnam", "Extra", "Van's Aircraft", "Ambulance", "Careflight"
                ];

                    // Transport airline ICAO -> Callsign name mapping
                const CARRIERS = {
                    "QFA": "QANTAS",
                    "AAL": "AMERICAN",
                    "BAW": "SPEEDBIRD",
                    "DAL": "DELTA",
                    "UAL": "UNITED",
                    "AFR": "AIR FRANS",
                    "DLH": "LUFTHANSA",
                    "KLM": "KLM",
                    "SVA": "SAUDIA",
                    "SWR": "SWISS",
                    "EZY": "EASY",
                    "RYR": "RYANAIR",
                    "ACA": "AIR CANADA",
                    "JAL": "JAPAN AIR",
                    "ANA": "ALL NIPPON",
                    "SIA": "SINGAPORE",
                    "MAS": "MALAYSIAN",
                    "CCA": "AIR CHINA",
                    "CES": "CHINA EASTERN",
                    "CSN": "CHINA SOUTHERN",
                    "CPA": "CATHAY",
                    "HVN": "VIETNAM AIRLINES",
                    "JST": "JETSTAR",
                    "VOZ": "VELOCITY",
                    "RXA": "REX",
                    "QLK": "Q-LINK"
                };
        
                const ultraLightAircraft = ["Brumby", "Sling", "Tecnam", "Van's Aircraft", "Van's", "BRM Aero", "Jabiru"];
                const aviationNumbers = {
                    '0': 'Zero', '1': 'One', '2': 'Two', 
                    '3': 'Tree', '4': 'Four', '5': 'Five',
                    '6': 'Six', '7': 'Seven', '8': 'Eight', 
                    '9': 'Niner'
                };

                // 在常量区添加数字范围
                const FORMAT1_RANGES = [
                    {min: 1000, max: 9999} // 任意四位数
                ];
                const FORMAT2_RANGES = [
                    {min: 160, max: 174} // 160-174区间
                ];

                let currentAnswer = {
                    type: null,     // 'letters' 或 'callsigns'
                    raw: "",        // 原始答案字符串
                    elements: []    // 解析后的元素数组（字母或纯呼号）
                };
                let currentAudio = null;

                //播放数字呼号
                function playFormat1() {
                    const callsignCount = parseInt(document.getElementById("callsignCount").value, 10);
                    let output = [];
                    let speechParts = [];
                    
                    for(let i=0; i<callsignCount; i++){
                        const number = generateNumber(FORMAT1_RANGES);
                        const [speech, formatted] = processFormat1(number);
                        
                        output.push(formatted);
                        speechParts.push(speech);
                    }
                    
                    currentAnswer = {
                        type: 'format1',
                        raw: output.join(', '),
                        elements: output
                    };
                    updateAnswer();
                    speakText(speechParts.join(', '));

                     // 新增自动聚焦到输入框
                    document.getElementById('userAnswer').focus(); // 自动聚焦到输入框
                }

                // Play a transport airline callsign (ICAO + 3-4 digit flight number)
                function playTransportAirline() {
                    const keys = Object.keys(CARRIERS);
                    const icao = keys[Math.floor(Math.random() * keys.length)];
                    const carrierName = CARRIERS[icao] || icao;

                    // choose 3 or 4 digit flight number
                    const len = (Math.random() < 0.5) ? 3 : 4;
                    let numStr = '';
                    let speechParts = '';

                    if (len === 3) {
                        const n = Math.floor(Math.random() * 900) + 100; // 100-999
                        numStr = n.toString();
                        // read digit-by-digit for 3-digit numbers
                        speechParts = numStr.split('').map(d => convertSingleNumber(d)).join(' ');
                    } else {
                        const n = Math.floor(Math.random() * 9000) + 1000; //1000-9999
                        // processFormat1 returns [spokenForm, numericString]
                        const res = processFormat1(n);
                        speechParts = res[0];
                        numStr = res[1];
                    }

                    const spoken = `${carrierName} ${speechParts}`;

                    // Save canonical raw answer as ICAO + digits (e.g., QFA1234)
                    currentAnswer = {
                        type: 'callsigns',
                        raw: `${icao}${numStr}`,
                        elements: [`${icao}${numStr}`]
                    };

                    updateAnswer();
                    speakText(spoken);
                    document.getElementById('userAnswer').focus();
                    updateButtonState();
                }

                // 辅助函数
                function generateNumber(ranges) {
                    const range = ranges[Math.floor(Math.random()*ranges.length)];
                    return Math.floor(Math.random()*(range.max - range.min +1)) + range.min;
                }

                function processFormat1(number) {
                    const numStr = number.toString().padStart(4, '0');
                    const part1 = numStr.substring(0, 2); // 直接使用两位字符串
                    const part2 = numStr.substring(2);    // 直接使用两位字符串

                    const speech1 = convertNumberGroup(part1);
                    const speech2 = convertNumberGroup(part2);

                    return [`${speech1} ${speech2}`, numStr];
                }

                // 添加辅助显示函数
                function showFeedback(message, isCorrect) {
                    const feedbackDiv = document.getElementById('answerFeedback');
                    feedbackDiv.innerHTML = message;
                    feedbackDiv.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
                }

                function base64ToBlob(base64Data, contentType = '', sliceSize = 512) {
                    const byteCharacters = atob(base64Data);
                    const byteArrays = [];
                    for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
                        const slice = byteCharacters.slice(offset, offset + sliceSize);
                        const byteNumbers = new Array(slice.length);
                        for (let i = 0; i < slice.length; i++) {
                            byteNumbers[i] = slice.charCodeAt(i);
                        }
                        const byteArray = new Uint8Array(byteNumbers);
                        byteArrays.push(byteArray);
                    }
                    return new Blob(byteArrays, { type: contentType });
                }
        
                function togglePauseResume() {
                    if (!currentAudio) return;
                    if (currentAudio.paused) {
                        currentAudio.play();
                    } else {
                        currentAudio.pause();
                    }
                }
        
                function stopPlayback() {
                    if (currentAudio) {
                        currentAudio.pause();
                        currentAudio.currentTime = 0;
                        currentAudio = null;
                    }
                    updateButtonState();
                }
        
                function updateButtonState() {
                    const pauseResumeBtn = document.getElementById('pauseResumeBtn');
                    const stopBtn = document.getElementById('stopBtn');
                    const isPlaying = currentAudio && !currentAudio.paused;
                    
                    pauseResumeBtn.disabled = !currentAudio;
                    stopBtn.disabled = !currentAudio;
                }
        
                function generateCustomLetters() {
                    const custom = document.getElementById("customLetters").value
                        .toUpperCase().replace(/[^A-Z]/g, '');
                    return custom || "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                }
        
                // Simulate Radio Tone feature removed
        
        
                async function speakText(text) {
                    const speed = parseFloat(document.getElementById('speed').value);
                    const selectedAccent = document.getElementById('accentSelect').value || 'australian';
                    const voices = ACCENT_VOICES[selectedAccent] || ACCENT_VOICES['australian'];
                    const selectedVoice = voices[Math.floor(Math.random() * voices.length)];
                    const languageCode = selectedVoice.split('-').slice(0, 2).join('-');

                    try {
                        const response = await fetch(
                            `https://texttospeech.googleapis.com/v1/text:synthesize?key=${GOOGLE_TTS_API_KEY}`,
                            {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    input: { text: text },
                                    voice: { languageCode: languageCode, name: selectedVoice },
                                    audioConfig: { audioEncoding: 'MP3', speakingRate: speed, pitch: Math.random() * 2 - 1 }
                                })
                            }
                        );

                        const data = await response.json();
                        const audioContent = data.audioContent;
                        const blob = base64ToBlob(audioContent, 'audio/mp3');

                        // If ATC tone simulation is enabled, post-process the MP3 blob
                        const atcEnabled = document.getElementById('atcToneCheckbox') && document.getElementById('atcToneCheckbox').checked;
                        let playBlob = blob;
                        if (atcEnabled) {
                            try {
                                playBlob = await renderBlobWithATCEffect(blob);
                            } catch (err) {
                                console.warn('ATC processing failed, playing original audio. Error:', err);
                                playBlob = blob;
                            }
                        }

                        const url = URL.createObjectURL(playBlob);

                        if (currentAudio) {
                            currentAudio.pause();
                            try { URL.revokeObjectURL(currentAudio.src); } catch (e) {}
                        }

                        currentAudio = new Audio(url);
                        currentAudio.addEventListener('play', updateButtonState);
                        currentAudio.addEventListener('pause', updateButtonState);
                        currentAudio.addEventListener('ended', updateButtonState);
                        currentAudio.play();
                    } catch (error) {
                        console.error('TTS synthesis failed:', error);
                        alert('TTS synthesis failed — check API key and network.');
                    }
                }

                // Render MP3 Blob through OfflineAudioContext to simulate VHF AM/ATC tone
                async function renderBlobWithATCEffect(mp3blob) {
                    const arrayBuffer = await mp3blob.arrayBuffer();
                    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    const decoded = await audioCtx.decodeAudioData(arrayBuffer);

                    const offlineCtx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(decoded.numberOfChannels, decoded.length, decoded.sampleRate);

                    const src = offlineCtx.createBufferSource();
                    src.buffer = decoded;

                    const bandpass = offlineCtx.createBiquadFilter();
                    bandpass.type = 'bandpass';
                    bandpass.frequency.value = 1000;
                    bandpass.Q.value = 0.8;

                    const lowpass = offlineCtx.createBiquadFilter();
                    lowpass.type = 'lowpass';
                    lowpass.frequency.value = 3000;
                    lowpass.Q.value = 0.7;

                    const highpass = offlineCtx.createBiquadFilter();
                    highpass.type = 'highpass';
                    highpass.frequency.value = 300;
                    highpass.Q.value = 0.7;

                    const waveShaper = offlineCtx.createWaveShaper();
                    waveShaper.curve = makeDistortionCurve(1.5);
                    waveShaper.oversample = '2x';

                    const compressor = offlineCtx.createDynamicsCompressor();
                    compressor.threshold.value = -30;
                    compressor.knee.value = 20;
                    compressor.ratio.value = 4;
                    compressor.attack.value = 0.005;
                    compressor.release.value = 0.2;

                    const masterGain = offlineCtx.createGain();
                    masterGain.gain.value = 0.95;

                    const amLFO = offlineCtx.createOscillator();
                    const amGain = offlineCtx.createGain();
                    amLFO.type = 'sine';
                    amLFO.frequency.value = 3.5 + Math.random() * 2.5;
                    amGain.gain.value = 0.06;
                    amLFO.connect(amGain);
                    amGain.connect(masterGain.gain);

                    const pitchLFO = offlineCtx.createOscillator();
                    const pitchGain = offlineCtx.createGain();
                    pitchLFO.type = 'sine';
                    pitchLFO.frequency.value = 5 + Math.random() * 4;
                    pitchGain.gain.value = 0.012;
                    pitchLFO.connect(pitchGain);
                    pitchGain.connect(src.playbackRate);

                    // Hiss noise
                    const noiseBuffer = offlineCtx.createBuffer(1, decoded.length, decoded.sampleRate);
                    const noiseData = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < noiseData.length; i++) {
                        noiseData[i] = (Math.random() * 2 - 1) * 0.02;
                    }
                    const noiseSrc = offlineCtx.createBufferSource();
                    noiseSrc.buffer = noiseBuffer;
                    noiseSrc.loop = false;
                    const noiseGain = offlineCtx.createGain();
                    noiseGain.gain.value = 0.02;

                    const durationSec = decoded.duration || (decoded.length / decoded.sampleRate);
                    const bursts = Math.max(1, Math.floor(durationSec / 3));
                    for (let b = 0; b < bursts; b++) {
                        const start = Math.random() * durationSec;
                        const burstLen = 0.08 + Math.random() * 0.18;
                        noiseGain.gain.setValueAtTime(0.02, start);
                        noiseGain.gain.linearRampToValueAtTime(0.16 + Math.random() * 0.12, start + 0.005);
                        noiseGain.gain.linearRampToValueAtTime(0.02, start + burstLen);
                    }

                    // Persistent high-frequency tone (bright, stable)
                    const highToneOsc = offlineCtx.createOscillator();
                    highToneOsc.type = 'sine';
                    highToneOsc.frequency.value = 200;
                    const highToneGain = offlineCtx.createGain();
                    highToneGain.gain.value = 0.01;

                    // Connect graph
                    src.connect(waveShaper);
                    waveShaper.connect(bandpass);
                    bandpass.connect(highpass);
                    highpass.connect(lowpass);
                    lowpass.connect(compressor);
                    compressor.connect(masterGain);
                    masterGain.connect(offlineCtx.destination);

                    noiseSrc.connect(noiseGain);
                    noiseGain.connect(compressor);

                    highToneOsc.connect(highToneGain);
                    highToneGain.connect(compressor);

                    src.start(0);
                    noiseSrc.start(0);
                    amLFO.start(0);
                    pitchLFO.start(0);
                    highToneOsc.start(0);

                    const rendered = await offlineCtx.startRendering();

                    // Normalize rendered to original decoded peak
                    function getPeak(buf) {
                        let peak = 0;
                        for (let ch = 0; ch < buf.numberOfChannels; ch++) {
                            const data = buf.getChannelData(ch);
                            for (let i = 0; i < data.length; i++) {
                                const v = Math.abs(data[i]);
                                if (v > peak) peak = v;
                            }
                        }
                        return peak;
                    }

                    const origPeak = Math.max(getPeak(decoded), 1e-9);
                    const renderedPeak = Math.max(getPeak(rendered), 1e-9);
                    let neededGain = origPeak / renderedPeak;

                    if (neededGain > 0 && Math.abs(neededGain - 1) > 1e-3) {
                        let maxAfter = 0;
                        for (let ch = 0; ch < rendered.numberOfChannels; ch++) {
                            const data = rendered.getChannelData(ch);
                            for (let i = 0; i < data.length; i++) {
                                data[i] = data[i] * neededGain;
                                const v = Math.abs(data[i]);
                                if (v > maxAfter) maxAfter = v;
                            }
                        }
                        if (maxAfter > 1) {
                            const reduce = 1 / maxAfter;
                            for (let ch = 0; ch < rendered.numberOfChannels; ch++) {
                                const data = rendered.getChannelData(ch);
                                for (let i = 0; i < data.length; i++) {
                                    data[i] = data[i] * reduce;
                                }
                            }
                        }
                    }

                    const wavBlob = audioBufferToWavBlob(rendered);
                    audioCtx.close();
                    return wavBlob;
                }

                // Distortion curve generator
                function makeDistortionCurve(amount) {
                    const k = typeof amount === 'number' ? amount : 50;
                    const nSamples = 44100;
                    const curve = new Float32Array(nSamples);
                    const deg = Math.PI / 180;
                    for (let i = 0; i < nSamples; ++i) {
                        const x = i * 2 / nSamples - 1;
                        curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
                    }
                    return curve;
                }

                // Encode AudioBuffer to WAV Blob (16-bit PCM)
                function audioBufferToWavBlob(buffer) {
                    const numOfChan = buffer.numberOfChannels;
                    const length = buffer.length * numOfChan * 2 + 44;
                    const bufferArray = new ArrayBuffer(length);
                    const view = new DataView(bufferArray);

                    function writeString(view, offset, string) {
                        for (let i = 0; i < string.length; i++) {
                            view.setUint8(offset + i, string.charCodeAt(i));
                        }
                    }

                    let offset = 0;
                    writeString(view, offset, 'RIFF'); offset += 4;
                    view.setUint32(offset, 36 + buffer.length * numOfChan * 2, true); offset += 4;
                    writeString(view, offset, 'WAVE'); offset += 4;
                    writeString(view, offset, 'fmt '); offset += 4;
                    view.setUint32(offset, 16, true); offset += 4;
                    view.setUint16(offset, 1, true); offset += 2;
                    view.setUint16(offset, numOfChan, true); offset += 2;
                    view.setUint32(offset, buffer.sampleRate, true); offset += 4;
                    view.setUint32(offset, buffer.sampleRate * numOfChan * 2, true); offset += 4;
                    view.setUint16(offset, numOfChan * 2, true); offset += 2;
                    view.setUint16(offset, 16, true); offset += 2;
                    writeString(view, offset, 'data'); offset += 4;
                    view.setUint32(offset, buffer.length * numOfChan * 2, true); offset += 4;

                    for (let i = 0; i < buffer.length; i++) {
                        for (let channel = 0; channel < numOfChan; channel++) {
                            const sample = buffer.getChannelData(channel)[i];
                            const s = Math.max(-1, Math.min(1, sample));
                            view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
                            offset += 2;
                        }
                    }

                    return new Blob([view], { type: 'audio/wav' });
                }
        
        
                function playLetters() {
                    const letters = generateCustomLetters();
                    const letterCount = parseInt(document.getElementById("letterCount").value, 10);
                    const randomString = Array.from({length: letterCount}, () => 
                        letters[Math.floor(Math.random() * letters.length)]
                    ).join('');
                    
                    currentAnswer = {
                        type: 'letters',
                        raw: randomString,
                        elements: [randomString]
                    };
                    
                    updateAnswer();
                    speakText(randomString.split('').map(c => aviationMap[c]).join(' '));

                     // 新增自动聚焦到输入框
                     document.getElementById('userAnswer').focus(); // 自动聚焦到输入框
                }
                
                //播放模拟呼号
                function playSimulated() {
                    const callsignCount = parseInt(document.getElementById("callsignCount").value, 10);
                    let output = [];
                    let speechParts = [];
                    let callsignList = [];
                    
                    for(let i=0; i<callsignCount; i++){
                        const aircraft = aircraftTypes[Math.random()*aircraftTypes.length|0];
                        let callsign, speech;
                        
                        if(ultraLightAircraft.includes(aircraft)) {
                            // 生成四位数呼号并确保两位分组
                            const part1 = Math.floor(Math.random()*90)+10; // 10-99
                            const part2 = Math.floor(Math.random()*90)+10;
                            callsign = part1.toString() + part2.toString().padStart(2, '0'); // 强制四位数
                            
                            // 调用统一的数字转换函数
                            speech = [
                                convertNumberGroup(part1.toString().padStart(2, '0')), // 前两位
                                convertNumberGroup(part2.toString().padStart(2, '0'))  // 后两位
                            ].join(' ');
                        } else {
                            const isLettersOnly = Math.random() < 0.5;
                            
                            if(isLettersOnly) {
                                callsign = Array.from({length:3}, () => 
                                    String.fromCharCode(65 + Math.random()*26|0)
                                ).join('');
                                speech = callsign.split('').map(c => aviationMap[c]).join(' ');
                            } else {
                                let hasLetter = false, hasNumber = false;
                                do {
                                    callsign = '';
                                    hasLetter = false;
                                    hasNumber = false;
                                    for(let j=0; j<3; j++) {
                                        if(Math.random() < 0.5) {
                                            callsign += String.fromCharCode(65 + Math.random()*26|0);
                                            hasLetter = true;
                                        } else {
                                            callsign += Math.random()*10|0;
                                            hasNumber = true;
                                        }
                                    }
                                } while(!(hasLetter && hasNumber));
                                
                                speech = callsign.split('').map(c => {
                                    return /[A-Z]/.test(c) ? aviationMap[c] : convertSingleNumber(c);
                                }).join(' ');
                            }
                        }
                        
                        output.push(`${aircraft} ${callsign}`);
                        callsignList.push(callsign.replace(/[^A-Z0-9]/g, ''));
                        speechParts.push(`${aircraft} ${speech}`);
                    }
                    
                    currentAnswer = {
                        type: 'callsigns',
                        raw: output.join(', '),
                        elements: callsignList
                    };
                    updateAnswer();
                    speakText(speechParts.join(', '));

                     // 新增自动聚焦到输入框
                    document.getElementById('userAnswer').focus(); // 自动聚焦到输入框
                }
        
                // 辅助函数保持不变...
                function convertNumberGroup(twoDigitStr) {
                    const firstDigit = twoDigitStr[0];
                    const secondDigit = twoDigitStr[1];

                    // 处理前导零的情况 (如 "05" -> Zero Five)
                    if (firstDigit === '0') {
                        if (secondDigit === '0') return 'Zero Zero';
                        return `Zero ${aviationNumbers[secondDigit]}`;
                    }

                    // 处理10-19的特殊读法
                    if (firstDigit === '1') {
                        const num = parseInt(twoDigitStr, 10);
                        switch(num) {
                            case 10: return 'Ten';
                            case 11: return 'Eleven';
                            case 12: return 'Twelve';
                            case 13: return 'Thirteen';
                            case 14: return 'Fourteen';
                            case 15: return 'Fifteen';
                            case 16: return 'Sixteen';
                            case 17: return 'Seventeen';
                            case 18: return 'Eighteen';
                            case 19: return 'Nineteen';
                        }
                    }

                    // 处理20-99的读法
                    let tenPart = aviationNumbers[firstDigit]
                        .replace('Two', 'Twenty')
                        .replace('Tree', 'Thirty')
                        .replace('Four', 'Forty')
                        .replace('Five', 'Fifty')
                        .replace('Six', 'Sixty')
                        .replace('Seven', 'Seventy')
                        .replace('Eight', 'Eighty')
                        .replace('Niner', 'Ninety');

                    if (secondDigit === '0') {
                        return tenPart; // 整十数如30 -> Thirty
                    } else {
                        return `${tenPart} ${aviationNumbers[secondDigit]}`; // 非整十数如34 -> Thirty Four
                    }
                }

                function convertSingleNumber(numChar) {
                    return aviationNumbers[numChar];
                }
        
                // 修改答案显示逻辑
                function updateAnswer() {
                    const div = document.getElementById('answer');
                    div.textContent = currentAnswer.raw;
                    document.getElementById('userAnswer').value = '';
                    document.getElementById('answerFeedback').textContent = '';
                    document.getElementById('answerFeedback').className = 'feedback';
                }

                function updateSpeed(v) {
                    document.getElementById('speedValue').textContent = v;
                }
        
                function toggleAnswer() {
                    const div = document.getElementById('answer');
                    const icon = document.getElementById('toggleIcon');
                    const text = document.getElementById('toggleText');
                    
                    if(div.style.display === 'none') {
                        div.style.display = 'block';
                        icon.textContent = '👁️';
                        text.textContent = 'Hide Answer';
                    } else {
                        div.style.display = 'none';
                        icon.textContent = '🔍';
                        text.textContent = 'Show Answer';
                    }
                }
        
                document.addEventListener('visibilitychange', function() {
                    if (document.hidden) {
                        stopPlayback();
                    }
                });
            
                // 改进的答案核对函数
                function checkAnswer() {
                    const cleanInput = (str) => str.toUpperCase().replace(/[^A-Z0-9]/g, '');
                    const userInput = document.getElementById('userAnswer').value;
                    const feedbackDiv = document.getElementById('answerFeedback');
                    
                    // 清空反馈样式
                    feedbackDiv.className = 'feedback';
                    feedbackDiv.innerHTML = '';

                    // 处理呼号模式
                    if(currentAnswer.type === 'callsigns') {
                        // 拆分用户输入为多个呼号（允许任意分隔符）
                        const userCallsigns = userInput.split(/[^a-zA-Z0-9]+/)
                            .filter(Boolean)
                            .map(cleanInput);

                        // Answer validation logic
                        const expected = currentAnswer.elements;
                        let errorDetails = [];
                        
                        // Check for matching count
                        if(userCallsigns.length !== expected.length) {
                            feedbackDiv.innerHTML = `
                                <div class="error-header">⚠ Expected ${expected.length} call signs, but you entered ${userCallsigns.length}</div>
                                <div class="correct-all">Correct Answer: ${expected.join(', ')}</div>
                            `;
                            feedbackDiv.className += ' incorrect';

                            // Remove focus from input field after submission
                            document.getElementById('userAnswer').blur();

                            return;
                        }

                        // Compare each call sign and record errors
                        expected.forEach((correct, index) => {
                            const userAnswer = userCallsigns[index];
                            if(userAnswer !== correct) {
                                errorDetails.push({
                                    position: index + 1,
                                    user: userAnswer || "[Empty Input]",
                                    correct: correct
                                });
                            }
                        });

                        // Build feedback message
                        if(errorDetails.length === 0) {
                            feedbackDiv.innerHTML = '✅ All call signs are correct!';
                            feedbackDiv.className += ' correct';
                        } else {
                            let errorList = errorDetails.map(err => 
                                `- Call sign ${err.position} is incorrect: Expected <span class="correct-highlight">${err.correct}</span>, but you entered <span class="user-error">${err.user}</span>`
                            ).join('<br>');

                            feedbackDiv.innerHTML = `
                                <div class="error-header">⚠ Found ${errorDetails.length} errors:</div>
                                <div class="error-details">${errorList}</div>
                                <div class="correct-all">Correct Answer: ${expected.join(', ')}</div>
                            `;
                            feedbackDiv.className += ' incorrect';
                        }
                    }
                    // Letter mode retains original logic
                    else if(currentAnswer.type === 'letters') {
                        const userClean = cleanInput(userInput);
                        const correctClean = cleanInput(currentAnswer.raw);
                        
                        if(userClean === correctClean) {
                            feedbackDiv.textContent = '✅ Correct Answer!';
                            feedbackDiv.className += ' correct';
                        } else {
                            feedbackDiv.textContent = `⚠ Incorrect Answer, Correct Answer: ${currentAnswer.raw}`;
                            feedbackDiv.className += ' incorrect';
                        }
                    }
                    // Add logic for format-based answers
                    else if(currentAnswer.type.startsWith('format')) {
                        const cleanInput = (str) => str.toUpperCase().replace(/[^A-Z0-9]/g, '');
                        const userAnswers = userInput.split(/[^a-zA-Z0-9]+/)
                            .filter(Boolean)
                            .map(s => currentAnswer.type === 'format2' ? 
                                s.replace(/D$/i, '') + 'D' : // Standardize D suffix
                                s.padStart(4, '0').substring(0,4));
                        
                        const expected = currentAnswer.elements;
                        let errors = [];
                        
                        if(userAnswers.length !== expected.length) {
                            showFeedback(`⚠ Expected ${expected.length} call signs, but you entered ${userAnswers.length}`, false);

                            // Remove focus from input field after submission
                            document.getElementById('userAnswer').blur();

                            return;
                        }
                        
                        userAnswers.forEach((answer, i) => {
                            const cleanAnswer = cleanInput(answer);
                            const cleanExpected = cleanInput(expected[i]);
                            if(cleanAnswer !== cleanExpected) errors.push(`⚠ Call sign ${i+1} is incorrect, expected ${expected[i]}`);
                        });
                        
                        if(errors.length > 0) {
                            showFeedback(errors.join('<br>') + `<br>Correct Answer: ${expected.join(', ')}`, false);
                        } else {
                            showFeedback('✅ All call signs are correct!', true);
                        }
                    }

                    // 新增：提交答案后，移除输入框焦点
                    document.getElementById('userAnswer').blur(); // 新增：移除输入框焦点
                }
            
                // 添加辅助显示函数
                function showFeedback(message, isCorrect) {
                    const feedbackDiv = document.getElementById('answerFeedback');
                    feedbackDiv.innerHTML = message;
                    feedbackDiv.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
                }
                
                // 在脚本末尾添加键盘事件监听
                document.addEventListener('keydown', handleKeyboardShortcuts);

                // 键盘处理函数
                function handleKeyboardShortcuts(event) {
                    const activeTag = document.activeElement.tagName.toLowerCase();
                    
                    // 排除输入框聚焦状态
                    if (activeTag === 'input' || activeTag === 'textarea') return;

                    switch(event.key.toLowerCase()) {
                        case ' ': // 空格键：播放/暂停
                            event.preventDefault();
                            togglePauseResume();
                            break;
                            
                        case 'enter': // 回车键：提交答案
                            event.preventDefault();
                            checkAnswer();
                            break;
                            
                        case 'arrowleft': // 左箭头：减慢语速
                            adjustSpeed(-0.1);
                            break;
                            
                        case 'arrowright': // 右箭头：加快语速
                            adjustSpeed(0.1);
                            break;
                            
                        case 'r': // R键：重新生成题目
                            if(event.ctrlKey) break; // 避免与浏览器刷新冲突
                            event.preventDefault();
                            if(currentAnswer.type === 'callsigns') playSimulated();
                            else if(currentAnswer.type === 'letters') playLetters();
                            break;
                            
                        case 'h': // H键：显示/隐藏答案
                            event.preventDefault();
                            toggleAnswer();
                            break;
                    }
                }

            
            </script>
        </section>
    </main>

    <footer>
        <div class="footer-content">
          <p>© 2025 Yohann's Aviation Note. All rights reserved.</p>
          <p>
            This project is open source under the <a href="https://www.gnu.org/licenses/agpl-3.0.html" target="_blank">GNU AGPLv3 license</a>,
            for non-commercial use only. Cited content has been marked, infringement please contact <a href="yuhan_zhao@nuaa.edu.cn">Email</a>.
          </p>
        </div>
    </footer>
</body>
</html>
